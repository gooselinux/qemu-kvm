From f5c13e69a30ae0ab1a2d55f50e0a1750ff9d5fcc Mon Sep 17 00:00:00 2001
From: Luiz Capitulino <lcapitulino@redhat.com>
Date: Thu, 3 Mar 2011 16:54:39 -0300
Subject: [PATCH 03/12] Revert "Implement drive_del to decouple block removal from device removal (v2)"

RH-Reverts: fd89fe04766ca0a2b087b12911e1f8ecdfc3b7ad
RH-Reverts-patchwork-id: 18388
Bugzilla-related: 677170
Signed-off-by: Luiz Capitulino <lcapitulino@redhat.com>
---
 hw/device-hotplug.c |   37 -------------------------------------
 qemu-monitor.hx     |   39 ---------------------------------------
 sysemu.h            |    1 -
 3 files changed, 0 insertions(+), 77 deletions(-)

diff --git a/hw/device-hotplug.c b/hw/device-hotplug.c
index 16d7950..3b957b2 100644
--- a/hw/device-hotplug.c
+++ b/hw/device-hotplug.c
@@ -110,40 +110,3 @@ int simple_drive_add(Monitor *mon, const QDict *qdict, QObject **ret_data)
 
     return 0;
 }
-
-int do_drive_del(Monitor *mon, const QDict *qdict, QObject **ret_data)
-{
-    const char *id = qdict_get_str(qdict, "id");
-    BlockDriverState *bs;
-    BlockDriverState **ptr;
-    Property *prop;
-
-    bs = bdrv_find(id);
-    if (!bs) {
-        qerror_report(QERR_DEVICE_NOT_FOUND, id);
-        return -1;
-    }
-
-    /* quiesce block driver; prevent further io */
-    qemu_aio_flush();
-    bdrv_flush(bs);
-    bdrv_close(bs);
-
-    /* clean up guest state from pointing to host resource by
-     * finding and removing DeviceState "drive" property */
-    for (prop = bs->peer->info->props; prop && prop->name; prop++) {
-        if (prop->info->type == PROP_TYPE_DRIVE) {
-            ptr = qdev_get_prop_ptr(bs->peer, prop);
-            if ((*ptr) == bs) {
-                bdrv_detach(bs, bs->peer);
-                *ptr = NULL;
-                break;
-            }
-        }
-    }
-
-    /* clean up host side */
-    drive_uninit(drive_get_by_blockdev(bs));
-
-    return 0;
-}
diff --git a/qemu-monitor.hx b/qemu-monitor.hx
index 6c9288d..e09bc88 100644
--- a/qemu-monitor.hx
+++ b/qemu-monitor.hx
@@ -140,45 +140,6 @@ Note: The "force" argument defaults to false.
 EQMP
 
     {
-        .name       = RFQDN_REDHAT "drive_del",
-        .args_type  = "id:s",
-        .params     = "device",
-        .help       = "remove host block device",
-        .user_print = monitor_user_noop,
-        .mhandler.cmd_new = do_drive_del,
-    },
-
-STEXI
-@item __com.redhat_drive_del @var{device}
-@findex __com.redhat_drive_del
-Remove host block device.  The result is that guest generated IO is no longer
-submitted against the host device underlying the disk.  Once a drive has
-been deleted, the QEMU Block layer returns -EIO which results in IO
-errors in the guest for applications that are reading/writing to the device.
-ETEXI
-SQMP
-__com.redhat_drive_del
-----------
-
-    {
-Remove host block device.  The result is that guest generated IO is no longer
-submitted against the host device underlying the disk.  Once a drive has
-been deleted, the QEMU Block layer returns -EIO which results in IO
-errors in the guest for applications that are reading/writing to the device.
-
-Arguments:
-
-- "id": the device's ID (json-string)
-
-Example:
-
--> { "execute": "drive_del", "arguments": { "id": "block1" } }
-<- { "return": {} }
-
-EQMP
-
-    {
-
         .name       = "change",
         .args_type  = "device:B,target:F,arg:s?",
         .params     = "device filename [format]",
diff --git a/sysemu.h b/sysemu.h
index a6d4a59..145964d 100644
--- a/sysemu.h
+++ b/sysemu.h
@@ -218,7 +218,6 @@ void qemu_system_cpu_hot_add(int cpu, int state);
 
 DriveInfo *add_init_drive(const char *opts);
 int simple_drive_add(Monitor *mon, const QDict *qdict, QObject **ret_data);
-int do_drive_del(Monitor *mon, const QDict *qdict, QObject **ret_data);
 
 /* pci-hotplug */
 void pci_device_hot_add(Monitor *mon, const QDict *qdict);
-- 
1.7.4.rc1.16.gd2f15e


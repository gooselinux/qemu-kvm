From fd89fe04766ca0a2b087b12911e1f8ecdfc3b7ad Mon Sep 17 00:00:00 2001
From: Markus Armbruster <armbru@redhat.com>
Date: Thu, 17 Feb 2011 09:32:46 -0200
Subject: [PATCH 10/13] Implement drive_del to decouple block removal from device removal (v2)

RH-Author: Markus Armbruster <armbru@redhat.com>
Message-id: <1297935168-2576-11-git-send-email-armbru@redhat.com>
Patchwork-id: 18388
O-Subject: [PATCH RHEL6.0.Z qemu-kvm 10/12] Implement drive_del to decouple
	block removal from device removal (v2)
Bugzilla: 677170
RH-Acked-by: Marcelo Tosatti <mtosatti@redhat.com>
RH-Acked-by: Kevin Wolf <kwolf@redhat.com>
RH-Acked-by: Jes Sorensen <Jes.Sorensen@redhat.com>

From: Ryan Harper <ryanh@us.ibm.com>

BZ: 654682
Upstream-status: accepted

Currently device hotplug removal code is tied to device removal via
ACPI.  All pci devices that are removable via device_del() require the
guest to respond to the request.  In some cases the guest may not
respond leaving the device still accessible to the guest.  The management
layer doesn't currently have a reliable way to revoke access to host
resource in the presence of an uncooperative guest.

This patch implements a new monitor command, drive_del, which
provides an explicit command to revoke access to a host block device.

drive_del first quiesces the block device (qemu_aio_flush;
bdrv_flush() and bdrv_close()).  This prevents further IO from being
submitted against the host device.  Finally, drive_del cleans up
pointers between the drive object (host resource) and the device
object (guest resource).

Signed-off-by: Ryan Harper <ryanh@us.ibm.com>
Signed-off-by: Kevin Wolf <kwolf@redhat.com>
(cherry picked from commit 9063f81415f3518ef8206e74085c2a92c96890a0)

Since upstream does not expose a drive_del QMP command, put this command
under the __com.redhat namespace.

Signed-off-by: Anthony Liguori <aliguori@us.ibm.com>
--
v1 -> v2
 - Remove trailing whitespace
 - Change drive_get_by_id to drive_get_by_blockdev to match upstream

Signed-off-by: Eduardo Habkost <ehabkost@redhat.com>
Signed-off-by: Markus Armbruster <armbru@redhat.com>
---
 hw/device-hotplug.c |   37 +++++++++++++++++++++++++++++++++++++
 qemu-monitor.hx     |   39 +++++++++++++++++++++++++++++++++++++++
 sysemu.h            |    1 +
 3 files changed, 77 insertions(+), 0 deletions(-)

Signed-off-by: Luiz Capitulino <lcapitulino@redhat.com>
---
 hw/device-hotplug.c |   37 +++++++++++++++++++++++++++++++++++++
 qemu-monitor.hx     |   39 +++++++++++++++++++++++++++++++++++++++
 sysemu.h            |    1 +
 3 files changed, 77 insertions(+), 0 deletions(-)

diff --git a/hw/device-hotplug.c b/hw/device-hotplug.c
index 3b957b2..16d7950 100644
--- a/hw/device-hotplug.c
+++ b/hw/device-hotplug.c
@@ -110,3 +110,40 @@ int simple_drive_add(Monitor *mon, const QDict *qdict, QObject **ret_data)
 
     return 0;
 }
+
+int do_drive_del(Monitor *mon, const QDict *qdict, QObject **ret_data)
+{
+    const char *id = qdict_get_str(qdict, "id");
+    BlockDriverState *bs;
+    BlockDriverState **ptr;
+    Property *prop;
+
+    bs = bdrv_find(id);
+    if (!bs) {
+        qerror_report(QERR_DEVICE_NOT_FOUND, id);
+        return -1;
+    }
+
+    /* quiesce block driver; prevent further io */
+    qemu_aio_flush();
+    bdrv_flush(bs);
+    bdrv_close(bs);
+
+    /* clean up guest state from pointing to host resource by
+     * finding and removing DeviceState "drive" property */
+    for (prop = bs->peer->info->props; prop && prop->name; prop++) {
+        if (prop->info->type == PROP_TYPE_DRIVE) {
+            ptr = qdev_get_prop_ptr(bs->peer, prop);
+            if ((*ptr) == bs) {
+                bdrv_detach(bs, bs->peer);
+                *ptr = NULL;
+                break;
+            }
+        }
+    }
+
+    /* clean up host side */
+    drive_uninit(drive_get_by_blockdev(bs));
+
+    return 0;
+}
diff --git a/qemu-monitor.hx b/qemu-monitor.hx
index e09bc88..6c9288d 100644
--- a/qemu-monitor.hx
+++ b/qemu-monitor.hx
@@ -140,6 +140,45 @@ Note: The "force" argument defaults to false.
 EQMP
 
     {
+        .name       = RFQDN_REDHAT "drive_del",
+        .args_type  = "id:s",
+        .params     = "device",
+        .help       = "remove host block device",
+        .user_print = monitor_user_noop,
+        .mhandler.cmd_new = do_drive_del,
+    },
+
+STEXI
+@item __com.redhat_drive_del @var{device}
+@findex __com.redhat_drive_del
+Remove host block device.  The result is that guest generated IO is no longer
+submitted against the host device underlying the disk.  Once a drive has
+been deleted, the QEMU Block layer returns -EIO which results in IO
+errors in the guest for applications that are reading/writing to the device.
+ETEXI
+SQMP
+__com.redhat_drive_del
+----------
+
+    {
+Remove host block device.  The result is that guest generated IO is no longer
+submitted against the host device underlying the disk.  Once a drive has
+been deleted, the QEMU Block layer returns -EIO which results in IO
+errors in the guest for applications that are reading/writing to the device.
+
+Arguments:
+
+- "id": the device's ID (json-string)
+
+Example:
+
+-> { "execute": "drive_del", "arguments": { "id": "block1" } }
+<- { "return": {} }
+
+EQMP
+
+    {
+
         .name       = "change",
         .args_type  = "device:B,target:F,arg:s?",
         .params     = "device filename [format]",
diff --git a/sysemu.h b/sysemu.h
index 145964d..a6d4a59 100644
--- a/sysemu.h
+++ b/sysemu.h
@@ -218,6 +218,7 @@ void qemu_system_cpu_hot_add(int cpu, int state);
 
 DriveInfo *add_init_drive(const char *opts);
 int simple_drive_add(Monitor *mon, const QDict *qdict, QObject **ret_data);
+int do_drive_del(Monitor *mon, const QDict *qdict, QObject **ret_data);
 
 /* pci-hotplug */
 void pci_device_hot_add(Monitor *mon, const QDict *qdict);
-- 
1.7.4.rc1.16.gd2f15e

